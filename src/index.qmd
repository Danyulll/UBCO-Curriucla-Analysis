---
title: "UBCO-Curriucla-Analysis"
format: html
bibliography: references.bib
output-dir: ./docs
---
## Introduction to Network Analysis in R

A nice introduction to Network Analysis in R is given [here](https://www.jessesadler.com/post/network-analysis-with-r/)

The major players in the network analysis space for R are the Statnet packages, tidygraph, igrpah. Interactive graphs can be created with the vizNetowrk and networkD3 packages. For an example of the some of the interactive visualizations we could make look [here](https://christophergandrud.github.io/networkD3/). There is also plenty of support for these visualization in Shiny so we do we eventually make a dashboard style took these will make an easy addition.

Next I follow the tutorial by Jesse Sadler to introduce working with networks in R.

Generally to create graphs you will need an adjacency matrix (for the network, igraph, and tidygraph packages) or an edge-list data frame for the tidyverse workflow. Edge-list dataframes can be converted to adjacency matrix and so we opt for their creation when doing network analysis.

Edge-list data frames have at least two columns: "from" and "to" columns for describing connections between nodes. Other columns may be added to describes attributes of nodes or weights for edges. Each node requires a unique identifier, generally an integer. An example Edge-list data frame:

```{r Setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(message = FALSE, warning = FALSE, cache = TRUE)
```

```{r Load libraries}
# Load libraries
library(tidyverse)
library(network)
library(tidygraph)
library(ggraph)
library(visNetwork)
library(networkD3)
library(dplyr)
library(docstring)
```


```{r Edge and Node List Example}
edge_list <- tibble(from = c(1, 2, 2, 3, 4), to = c(2, 3, 4, 2, 1))
node_list <- tibble(id = 1:4, label = paste("node ", seq(1, 4)))

edge_list
node_list
```
Let's explore the various packages.

### network

We create a network object from the edge list.

```{r Network Object Example}
network <- network(
  edge_list,
  vertex.attr = node_list,
  matrix.type = "edgelist",
  ignore.eval = TRUE
)
network
```

Then we can visualize the graph. THe mode argument will use different algorithms to plot the graph.

```{r Plotting Network Example}
plot(network, vertex.cex = 4, mode = "circle")
```

### igraph

You need to remove the network package because there is a lot of overlap in the name space.

```{r Igraph Example}
# Detatch network and load igraph
detach(package:network)
rm(network)
library(igraph)
```
We need to convert our edge list to a form usable by igraph.

```{r Igraph Network Object Example}
network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)
network
```
The information for the graph description is shorthand for a few things. D is directed, N says we have a name attribute, the first - means not weight weighted, the second - means not bipartite, 4 is the number of nodes, 5 is the number of edges, attr tells use there are two node attributes, and a print out of all edges. We can also plot this graph and again layout is an argument to control the algorithm for plotting the network.

```{r Ploting Igraph Example}
plot(
  network,
  layout = layout_with_graphopt,
  vertex.size = 30,
  vertex.label.cex = 1,
  edge.arrow.size = 0.8
)
```
### tidygraph and ggraph

If we want to leverage the tidyverse workflow and ggplot we can use the tidygraph package. We first need to make a tbl_graph object.

```{r Tidygraph Example}
network_tbl <- tbl_graph(nodes = node_list,
                         edges = edge_list,
                         directed = TRUE)
network_tbl
```
The output states Node Data is active. This means if you manipulate data in this object it will manipulate the Node Data table. Use the activate() function to switch to the other table in the object. Now we can plot our network in a ggplot style.

```{r Making ggraph Example}
ggraph(network_tbl, layout = "graphopt") +
  geom_node_point() +
  geom_edge_link() +
  geom_node_text(aes(label = label), repel = TRUE) +
  theme_graph()
```

You can also make arc graphs.

```{r Arc Graph Example}
ggraph(network_tbl, layout = "linear") +
    geom_edge_arc(alpha = 0.8) +
    scale_edge_width(range = c(0.2, 2)) +
    geom_node_text(aes(label = label)) +
    labs() +
    theme_graph()
```

### Interactive visualizations

It is quite easy to turn our previously static graphs into interactive visualizations. [visNetwork](https://datastorm-open.github.io/visNetwork/) uses JavaScript to create these visualizations and has create documentation for increasing the interactivity of our graphs. We will use this visualization package for our analysis. Others however do exist like networkD3.

```{r Interactive Viz Example, warning=FALSE}
visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle")
```


## Curricular Analytics

The following is adapted from [@heileman2018curricular].

Curriculum is modeled as a *directed acyclic graph* (DAG) where courses are nodes and requisite relationships between nodes are directed edges. Mathematically a *curriculum graph* is denoted $G_c = V(V,E)$ where $v_1,\dots,v_n \in V$ are courses and the directed edge $(v_i,v_j) \in E$ is a requisite from $v_i$ to $v_j$ that must be completed before enrollment in $v_j$. Nodes in these graph are organized in columns representing each term in a curriculum. Edges down columns are co-requisites and edges across columns are pre-requisites.

With this framework of modeling comes a host of useful metrics for gaining insight about a curriculum graph's structure. Next we outline a few of the metrics and provide functions for calculating them.

First we construct a graph to showcase the metrics.

```{r Example Graph to Showcase CA Metrics}
edge_list <- tibble(from = c(1, 2, 1), to = c(2, 4, 3))
node_list <-
  tibble(id = as.character(1:4), label = paste0("v", seq(1, 4)))

coords <- matrix(ncol = 2,
                 byrow = T,
                 data = c(1, 0,
                          2, 0,
                          2, 1,
                          3, 0))

visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords)
```

### Delay Factor

*Delay factor* is a metric used to quantify the existent of long pathways through a curriculum graph. These longs paths indicate a chain of requisite relationships where if w a student were to fail a given course along the path they would suffer a heavily delayed graduation. The delay factor for a given node is the number of vertices in the longest path of $G_c$ that contains the given node. An isolated node's delay factor is defined to be 1 and means it can be taken in any term. We also calculate the total delay factor for $G_c$ as the sum of all delay factors in the graph.

```{r Define delay factor}
delay_factor <- function(edge_list, node_list) {
  #' Delay factor
  #'
  #' Calculates the delay factor for each node and the total delay factor of the curriculum graph. Delay factor is defined as the number of vertices in the longest path in G that pass through v. The function returns a list where bynode holds the delay factor for each node and total holds the delay factor for the graph.
  #'
  #' @param edge_list data frame containing the edge list of the graph.
  #' @param node_list data frame containing the node list of the graph.
  
  bynode <- data.frame(id = NA, df = NA)
  
  network <- graph_from_data_frame(d = edge_list,
                                   vertices = node_list,
                                   directed = TRUE)
  paths <- list()
  
 
  for (v in as.numeric(node_list$id)) {
    paths <- c(paths, all_simple_paths(network, from = v, mode = "out"))
  }
  
  for (v in as.numeric(node_list$id)) {
    max_length <- 0
    for (path in paths) {
      if (v %in% as.vector(path) &&
          max_length < length(as.vector(path))) {
        max_length <- length(as.vector(path))
      }
    }
    
    if (max_length == 0) {
      max_length <- 1
    }
    bynode <-
      rbind(bynode, data.frame(id = as.character(v), df = max_length))
    
  }
  
  bynode <- na.omit(bynode)
  total <- sum(bynode$df)
  
  list(bynode = bynode, total = total)
}
```

```{r Visualize example delay factor}
df_df <- delay_factor(edge_list, node_list)
df <- df_df$bynode



node_list <- left_join(node_list, df, by = c("id" = "id"))


network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)

visNetwork(node_list, edge_list,
           submain = list(text = paste("Total df:", df_df$total))) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(selectNode = "function(properties) {
      alert(' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}")
```

### Blocking Factor

*Blocking factor* is a quantity that captures a course's ability to gatekeep other courses. That is, if you fail a course with a high blocking factor you are blocked from taking many other courses. The blocking factor of a node is the number of nodes reachable from the given node. The total blocking factor of the graph is the sum of all individual blocking factors.

```{r Define blocking factor}
blocking_factor <- function(edge_list, node_list) {
  #' Blocking factor
  #'
  #' Calculates the blocking factor for each node and the total blocking factor of the curriculum graph. The blocking factor of a node v is the number of nodes reachable from v. The function returns a list where bynode holds the blocking factor for each node and total holds the blocking factor for the graph.
  #'
  #' @param edge_list data frame containing the edge list of the graph.
  #' @param node_list data frame containing the node list of the graph.
  
  bynode <- data.frame(id = NA, bf = NA)
  
  network <- graph_from_data_frame(d = edge_list,
                                   vertices = node_list,
                                   directed = TRUE)
  paths <- list()

  for (v in as.numeric(node_list$id)) {
    paths <- c(paths, all_simple_paths(network, from = v, mode = "out"))
  }
  
  
  for (v in as.numeric(node_list$id)) {
    nodes_reachable <- c()
    for (path in paths) {
      curr_path <- as.vector(path)
      if (v %in% curr_path[1]) {
        nodes_reachable <- c(nodes_reachable, curr_path)
      }
    }
    
    nodes_reachable <- unique(nodes_reachable)
    nodes_reachable <- nodes_reachable[nodes_reachable != v]
    
    bynode <-
      rbind(bynode, data.frame(id = as.character(v), bf = length(nodes_reachable)))
  }
  
  bynode <- na.omit(bynode)
  
  list(bynode = bynode, total = sum(bynode$bf))
  
}
```

```{r Visualize example blocking factor}
bf_df <- blocking_factor(edge_list, node_list)
bf <- bf_df$bynode

node_list <- left_join(node_list, bf, by = c("id" = "id"))


network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)

visNetwork(node_list, edge_list,
           submain = list(text = paste("Total bf:", bf_df$total))) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(selectNode = "function(properties) {
      alert(' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf);}")
```

### Centrality Factor

*Centrality factor* indicates how central a node is to a curriculum. A node is considered central if it requires many pre-requisite courses and is itself a pre-requisite to many courses. Heileman et al. says in curricular analytics we are greatly interested in how learning outcomes achieved in one course are used in later courses and we therefore wish to identify key central courses in these paths [-@heileman2018curricular]. The centrality factor is meant to capture this and is defined as the number of nodes in all long paths that include the given node. A long path is defined to be a path with length greater than or equal to 3. Nodes who only fall on paths shorter than this are given a centrality of 0.

```{r Define centrality factor}
centrality_factor <- function(edge_list, node_list) {
  #' Centrality factor
  #'
  #' Calculates the centrality factor for each node. The centrality factor of a node v is the number of long paths containing v where a long path is one of length 3 or greater. The function returns a dataframe that holds the centrality factor for each node.
  #'
  #' @param edge_list data frame containing the edge list of the graph.
  #' @param node_list data frame containing the node list of the graph.
  
  bynode <-
    data.frame(id = as.numeric(node_list$id), cf = rep(0, length(node_list$id)))
  
  network <- graph_from_data_frame(d = edge_list,
                                   vertices = node_list,
                                   directed = TRUE)
  paths <- list()

  for (v in as.numeric(node_list$id)) {
    paths <- c(paths, all_simple_paths(network, from = v, mode = "out"))
  }
  
  for (path in paths) {
    curr_path <- as.vector(path)
    if (length(curr_path) >= 3) {
      long_path_nodes <- curr_path[c(-1, -length(curr_path))]
      
      for (node in long_path_nodes) {
        bynode[node, c("cf")] <- bynode[node, c("cf")] + length(curr_path)
      }
    }
  }
  
  bynode$id <- as.character(bynode$id)
  bynode
}
```

```{r Visualize example centrality factor}
cf <- centrality_factor(edge_list, node_list)

node_list <- left_join(node_list, cf, by = c("id" = "id"))


network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)

visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(selectNode = "function(properties) {
      alert(' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf);}")
```

### Structural Complexity and Course Cruciality
*Structural Complexity* is a metric that assess the impact that curricular structure will have on a student's journey through a curriculum. In simulations it was find that a high structural complexity correlated to decreased graduation rates. The structural complexity for a given graph is the sum of all nodes' crucialities. Cruciality is simply a linear combination of a given node's delay and blocking factors.

```{r Define structural complexity}
structural_complexity <- function(edge_list, node_list) {
  #' Structural Complexity
  #'
  #' Calculates the cruciality for each node and the structural complexity for the entire curriculum graph. The structural complexity is the sum of all node crucialities.The function returns a list where bynode holds the cruciality for each node and total holds the structural complexity for the graph.
  #'
  #' @param edge_list data frame containing the edge list of the graph.
  #' @param node_list data frame containing the node list of the graph.
  
  
  bf_df <- blocking_factor(edge_list, node_list)
  bf <- bf_df$bynode$bf
  
  df_df <- delay_factor(edge_list, node_list)
  df <- df_df$bynode$df
  
  bynode <- data.frame(id = node_list$id, sc = (bf + df))
  
  list(bynode = bynode, total = sum(bynode$sc))
  
}
```


```{r Visualize example structural complexity}
edge_list <- tibble(from = c(1, 1, 1, 3), to = c(2, 3, 4, 5))
node_list <-
  tibble(id = as.character(1:5), label = paste0("v", seq(1, 5)))

coords <- matrix(
  ncol = 2,
  byrow = T,
  data = c(1, 0,
           2, 0,
           2, 1,
           2, 2,
           3, 0)
)


sc <- structural_complexity(edge_list, node_list)$bynode

node_list <- left_join(node_list, sc, by = c("id" = "id"))


network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)

visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc);}")
```


## Bayesian Networks

*Bayesian Networks* (BNs) are a machine learning model that in the context of curricular analytics can be used for knowledge discovery and lowering the structural complexity of a curriculum graph [@slim2021restructuring]. Slim et al. showcased the use of BNs in curricula graphs as a means to statistically validate the restructuring of university programs through discovering latent nodes in the graph evaluating them using a likelihood-ratio test. They further mention the model's capability to be used in the prediction of student grades.

BNs have much support within R and the text *Bayesian Networks in R* provides a good introduction to many of the concepts used in this analysis [@nagarajan2013bayesian].

### Background

Explanations and examples are adapted from [@scutari2009learning].

Bayesian networks utilize DAGs to model a set of random variables, i.e., for the set $\mathbf{X}=\{X_1,\dots,X_p\}$ of random variables the DAG $G=(\mathbf{V},\mathbf{A})$ is constructed where $v_i \in \mathbf{V}$ corresponds to a random variable from our set $\mathbf{X}$ and $\mathbf{A}$ is the set of arcs (edges).

The DAG itself is a factorization of the joint probability distribution of $\mathbf{V}$. This factorization follows from the Markov property of Bayesian networks: every random variable $X_i$ directly depends only on its parents $\Pi_{X_i}$ or

$$P(X_1,\dots,X_v)=\prod^v_{i=1}P(X_i|\Pi_{X_i})\text{ (for discrete variables)}$$

probability distributions exist for each node as a result of this factorization, called *local probability distributions*. The joint probability distribution for all nodes is called the *global probability distribution*.

Bayesian network model selection is done through learning the graphical structure of a Bayesian network and then estimating the parameters of the local distribution functions. It is most common to assume the local distributions are multinomial for discrete data which fits our use case. Therefore for our use case we will have a data set of courses and grades that students got. The model will then learn casual relationships between courses and the resulting grades. For example perhaps the algorithm will learn that a high grade in MATH 100 is casually related to a high grade in MATH 101. Furthermore, a benefit of these models is we may include demographic or other information and see how these casually impact grades.

There are various algorithms to learn the structure of the BN however we opt to use *hill climbing greedy search* (hc) as done in [@slim2021restructuring]. For further information on what this algorithm does see [@scutari2009learning] and [@daly2007methods]. The general idea is that hc will use some score function while investigating candidate Bayesian networks and select the one that maximizes some set heuristic. As we are working with discrete data the heuristics available to us are the *likelihood*, *Akaike Information Criterion* (AIC), *Bayesian Information Criterion* (BIC), *Bayesian Dirichelt equivalent score* (BDE), and the *K2 score*.

[@slim2021restructuring] further showcases how one may learn the structure of a BN and calculate the likelihood of the model, then add a hidden node and calculate the new likelihood, and finally conduct a likelihood-ratio test to see if the model has improved. If the model has improved, the newly added node represents a potential course that could be included in the curriculum to reduce structural complexity and improve student performance. Note there won't be grade data for this new course so its conditional probability is calculated using *expectation-maximization* (EM).




### BNs in R

*bnlearn* is a popular package for using BNs. We now run through an example to demonstrate its use.

```{r Bnlearn Example Data,message = FALSE, warning = FALSE}
library(bnlearn)
data(learning.test)
kable(head(learning.test))
```

```{r Str of Learning.Test}
str(learning.test)
```

We learn the structure of this Bayesian network using hc. After doing so we can plot the network using visNetwork.

```{r Example of Learning Graph Structure}
bn.hc <- hc(learning.test, score = "aic")

label <- names(bn.hc$nodes)
node_list <- data.frame(id = label, label = label)
edge_list <- as.data.frame(bn.hc$arcs)

visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle")
```


## Analysis of UBCO Data Science Major Curriculum

### Setup

Our data set consists of course information from the data science program at UBCO. We have course codes, names, descriptions, and requisite relationships. 

```{r Read in data}
# Read in data
ubco <- read.csv("..\\data\\UBCO\\UBCO_Course_Calendar.csv")
str(ubco)
```

With this we can construct degree pathways through our curriculum and graph them. Since there are many electives within our program there are many possible curriculum graphs. We will analyze the most and least structurally complex curricula and see what patterns emerge. 

```{r Generate Curriculum Graphs - Major}
# Create list for storing pathways
Gc <- list()

for (i in 1:100) {
  # Generate degree pathway
  pathway <-
    data.frame(
      Course.Code = NA,
      Course.Name = NA,
      Course.Description = NA,
      Prerequisite = NA,
      Corequisite = NA,
      Equivalents = NA
    )
  
  # First Year
  pathway <- rbind(pathway, subset(ubco, Course.Code == "DATA 101"))
  samp <- sample(c("CHEM 111", "CHEM 121"), 1)
  pathway <- rbind(pathway, subset(ubco, Course.Code == samp))
  pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% c("MATH 100", "MATH 101")))
  samp <- sample(c(TRUE, FALSE), 1)
  
  if (samp) {
    pathway <- rbind(pathway, subset(ubco, Course.Code == "ENGL 109"))
  } else {
    samp <- sample(
      c(
        "ENGL 112",
        "ENGL 113",
        "ENGL 114",
        "ENGL 150",
        "ENGL 151",
        "ENGL 153",
        "ENGL 154",
        "ENGL 155",
        "ENGL 156"
      ),
      2
    )
    pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
  }
  
  
  samp <- sample(c("PHYS 111", "PHYS 112"), 1)
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
  samp <- sample(c("PHYS 121", "PHYS 122"), 1)
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
  pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% c("COSC 111", "COSC 121")))
  
  
  # Second Year
  pathway <-
    rbind(pathway, subset(
      ubco,
      Course.Code %in% c("MATH 200",
                         "MATH 221",
                         "STAT 230",
                         "COSC 221",
                         "COSC 222")
    ))
  
  
  # Third and Fourth Year
  pathway <-
    rbind(pathway, subset(
      ubco,
      Course.Code %in% c("DATA 301",
                         "DATA 311",
                         "COSC 304",
                         "STAT 303",
                         "PHIL 331")
    ))
  
  
  
  upper_year_data <-
    c("DATA 310", "DATA 315", "DATA 405", "DATA 407", "DATA 410")
  max_2_stat <- c("STAT 400", "STAT 401", "STAT 403", "STAT 406")
  
  # TODO I don't include MATH 409 or PHYS 420
  max_2_cosc_math_phys <-
    c(
      "COSC 303",
      "COSC 322",
      "COSC 329",
      "COSC 344",
      "COSC 407",
      "COSC 421",
      "MATH 303",
      "MATH 307"
    )
  course <- c()
  while (length(unique(course)) < 9) {
    var <- sample(c("1", "2", "3"), 1)
    
    if (var == 1) {
      course <- c(course, sample(max_2_stat, 1))
    } else if (var == 2) {
      course <- c(course, sample(max_2_cosc_math_phys, 1))
    } else if (var == 3) {
      course <- c(course, sample(upper_year_data, 1))
    }
  }
  
  pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% unique(course)))
  
  pathway <- na.omit(pathway)
  rownames(pathway) <- 1:nrow(pathway)
  
  # Construct node and edge list
  
  node_list <-
    data.frame(id = rownames(pathway), label = pathway$Course.Code)
  
  edge_list <- data.frame(from = NA, to = NA)
  
  for (node in node_list$label) {
    str <- subset(pathway, Course.Code == node)$Prerequisite
    course_code <- ""
    if (str != "") {
      course_code <- str_extract_all(str, "[A-Z]{4} [0-9]{3}")[[1]]
    }
    
    from <- rownames(subset(pathway, Course.Code == node))
    to <- rownames(subset(pathway, Course.Code %in% course_code))
    if (length(to) > 1) {
      for (id in to) {
        edge_list <- rbind(edge_list, data.frame(from = id, to = from))
      }
    } else {
      edge_list <- rbind(edge_list, data.frame(from = to[1], to = from))
    }
  }
  edge_list <- na.omit(edge_list)
  
  # Get structural complexity
  
  sc <- structural_complexity(edge_list, node_list)
  
  # Store in list
  results <-
    list(node_list = node_list,
         edge_list = edge_list,
         sc = sc)
  
  Gc <- c(Gc, list(results))
}
```

```{r Extract Max and Min Graphs}
# Initialize variables for maximum and minimum values
max_total <- -Inf
min_total <- Inf
max_index <- NULL
min_index <- NULL

# Iterate through Gc to find max and min indices
for (i in seq_along(Gc)) {
  total <- Gc[[i]]$sc$total
  if (total > max_total) {
    max_total <- total
    max_index <- i
  }
  if (total < min_total) {
    min_total <- total
    min_index <- i
  }
}

# Display the indices
print(paste("Index of maximum sc$total:", max_index))
print(paste("Index of minimum sc$total:", min_index))
```

### Maximum Structural Complexity

```{r Generate Node Coords Max}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, #
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, #
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, #
    5, 0,
    5, 1,
    5, 2,
    5, 3,
    5, 4, #
    6, 0,
    6, 1,
    6, 2
))
```


```{r Visualize Max SC}
# node_list <- Gc[[max_index]]$node_list
# edge_list <- Gc[[max_index]]$edge_list

# sc_df <- structural_complexity(edge_list,node_list)
# cf_df <- centrality_factor(edge_list,node_list)
# bf_df <- blocking_factor(edge_list,node_list)
# df_df <- delay_factor(edge_list,node_list)

# node_list <- left_join(node_list, sc_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, cf_df, by = c("id" = "id"))
# node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, df_df$bynode, by = c("id" = "id"))
# max_graph <- list(edge_list = edge_list, node_list = node_list, sc_total = sc_df$total, bf_total = bf_df$total, df_total = df_df$total)

#  save(max_graph, file = "./maxGraph.RData")

load("..\\data\\rdata\\maxGraph.RData")

visNetwork(
  max_graph$node_list,
  max_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    max_graph$sc_total,
    "Total Blocking Factor:",
    max_graph$bf_total,
    "Total Delay Factor:",
    max_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Examining our maximally complex graph we can learn the set of key courses that are contributing most to our metrics. The total structural complexity is 194, the total blocking factor is 80, and the total delay factor is 114.

The most central node in this graph by far is STAT 230 with a centrality factor of 138. In UBCO's Data Science program is it the first statistics course many students encounter and is a preq-requisite to many 3rd and 4th year classes. Coming in at second is MATH 101 at 95. This also makes sense as it is Calculus 2 as it is a pre-requisite for STAT 230 and the Calculus 3 class MATH 200. Finally COSC 221 is 3rd with 70. This course is discrete math and is a pre-requisite for STAT 230. This suggests as STAT 230 is so central and course that is its pre-requisite is also central.

The course with the greatest blocking factor is MATH 100 with a blocking factor of 17. This course is Calculus 1 and so it is likely unavoidable to for this course to have a high blocking factor. After all, Calulus is the foundation for many courses in a data science program and so it finds itself the root of many chains of edges.

The course with the greatest delay factor is tied for MATH 100, MATH 101, STAT 230, COSC 221, DATA 311, and DATA 410. These courses find themselves a part of the longest path in the graph of length 6. This suggests being able to take DATA 410 is difficult within this curriculum structure as it is very easy to get delayed along the pre-requisite path to this course.

The course with the largest structural complexity is MATH 100 with a score of 23. This is followed by MATH 101 at 20 and COSC 221 at 14. It is interesting that STAT 230 comes at 4th with only a strucutral complexity of 12. Because MATH 100 and 101 find them selves at the root of many paths it follow that they add quite heavily to the structural complexity of our graph.

These metrics suggest a revision of pathways including STAT 230, MATH 100, MATH 101, and COSC 221.

Here is a full table of the metrics
```{r printing max graph metrics}
kable(max_graph$node_list)
```

### Minimum Structural Complexity

```{r Generate Node Coords Min}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, 
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, 
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, 
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, 
    5, 0,
    5, 1,
    5, 2,
    5, 3, 
    6, 0,
    6, 1,
    6, 2, 
    6, 3 
))
```

```{r Visualize Min SC}
# node_list <- Gc[[min_index]]$node_list
# edge_list <- Gc[[min_index]]$edge_list

# sc_df <- structural_complexity(edge_list,node_list)
# cf_df <- centrality_factor(edge_list,node_list)
# bf_df <- blocking_factor(edge_list,node_list)
# df_df <- delay_factor(edge_list,node_list)

# node_list <- left_join(node_list, sc_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, cf_df, by = c("id" = "id"))
# node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, df_df$bynode, by = c("id" = "id"))

# min_graph <- list(edge_list = edge_list, node_list = node_list, sc_total = sc_df$total, bf_total = bf_df$total, df_total = df_df$total)

# save(min_graph, file = "./minGraph.RData")

load("../data/rdata/minGraph.RData")

visNetwork(
  min_graph$node_list,
  min_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    min_graph$sc_total,
    "Total Blocking Factor:",
    min_graph$bf_total,
    "Total Delay Factor:",
    min_graph$df_total
  )
) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Examining the minimally complex graph we see quite a large reduction in the total metrics. The total structurcal complexity is 148, the total blocking factor is 55, and the total delay factor is 93.

However the course with the highest centrality factor is once again STAT 230 at 110; the courses with the highest blocking factors are MATH 100 (14), MATH 101 (10), and COSC 221 (6); the courses with the highest delay factors are MATH 100, MATH 101, MATH 200, STAT 230, COSC 221, DATA 311, STAT 303, STAT 401, STAT 403, COSC 421, DATA 407, and DATA 315 all at 5—suggesting multiple longest pathways; and the courses with the greatest structural complexity are MATH 100 (19), MATH 101 (15), and COSC 221 (11).

These results tell us that while upper year electives can vary and reduce the over all metric scores, there are common courses who contribute the most to complexity. Based on this restructuring is need surrounding STAT 230 and COSC 221. Since STAT 230 leads in centrality by more than double across both graphs it is a course that earns increased focus and dedication of resources. Another option for STAT 230 would be the creation of new courses to lessen its affect as a bottleneck. It is unlikely much can be down with MATH 100 and MATH 101 as they are students' first introduction to Calculus and very foundational to all courses in the curriculum though further exploration is certainly warranted.


Here is a full table of the metrics
```{r printing min graph metrics}
kable(min_graph$node_list)
```


The difference in elective coruses that caused the total metric scores to be so different are given below.

The courses in the max graph that are not found in the min graph are:

```{r Printing max graph unique courses}
idx <- !(max_graph$node_list$label %in% min_graph$node_list$label)
kable(max_graph$node_list$label[idx])
```

The courses in the min graph that are not found in the max graph are:

```{r Printing min graph unique courses}
idx <- !(min_graph$node_list$label %in% max_graph$node_list$label)
kable(min_graph$node_list$label[idx])
```

## Analysis of UBCO Data Science Minor Curriculum
### With prereqs on
#### Setup

```{r Read in data - Minor prereq on}
# Read in data
ubco <- read.csv("..\\data\\UBCO\\UBCO_Course_Calendar.csv")
str(ubco)
```

```{r Generate Curriculum Graphs - Minor prereq on}
# Create list for storing pathways
Gc <- list()

for (i in 1:1000) {
  pathway <-
    data.frame(
      Course.Code = NA,
      Course.Name = NA,
      Course.Description = NA,
      Prerequisite = NA,
      Corequisite = NA,
      Equivalents = NA
    )
  # 30 Credits from:
  
  # Required courses
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% c("DATA 101","STAT 230", "DATA 301","DATA 311")))
  
  up_to_6_creds <- c("MATH 100", "MATH 101", "MATH 200", "MATH 221", "COSC 111", "COSC 121", "COSC 221", "COSC 222", "ECON 102", "APSC", "BIOL 202", "PSYO 373", "APSC 254")
  courses <- sample(up_to_6_creds,2)
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% courses))
  
upper_year_data <-
    c("DATA 310", "DATA 315", "DATA 405", "DATA 407", "DATA 410")
  max_3_cosc <- c("COSC 304","COSC 322","COSC 329","COSC 344", "COSC 421")
  max_6_stat <- c("STAT 303","STAT 401")
  cosc_cred <- 0
  stat_cred <- 0
  total_cred <- 0
  
  while (total_cred < 13) {
    x <- sample(1:3, 1)
    
    if (x == 1) {
      courses <- sample(upper_year_data, 1)
      if (sum(courses %in% pathway$Course.Code)==0) {
        pathway <-
          rbind(pathway, subset(ubco, Course.Code %in% courses))
        total_cred <- total_cred + 3
      }
      
    } else if (x == 2 & cosc_cred != 3) {
      courses <- sample(max_3_cosc, 1)
      if (sum(courses %in% pathway$Course.Code)==0) {
        pathway <-
          rbind(pathway, subset(ubco, Course.Code %in% courses))
        cosc_cred <- 3
        total_cred <- total_cred + 3
      }
    } else if (x == 3 & stat_cred < 7) {
      courses <- sample(max_6_stat)
      if (sum(courses %in% pathway$Course.Code)==0) {
        pathway <-
          rbind(pathway, subset(ubco, Course.Code %in% courses))
        stat_cred <- stat_cred + 3
        total_cred <- total_cred + 3
      }
    }
  }
  
  pathway <- na.omit(pathway)
  prereqs <- unlist(str_extract_all(subset(ubco,Course.Code %in% pathway$Course.Code)$Prerequisite, "[A-Z]{4} [0-9]{3}"))
  
  # TODO while this works, its an ugly solution
  for (i in 1:50) {
    prereqs <- c(prereqs,unlist(str_extract_all(subset(ubco,Course.Code %in% prereqs)$Prerequisite, "[A-Z]{4} [0-9]{3}")))
  }
  
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% prereqs))
  pathway <- pathway[!duplicated(pathway),]
  rownames(pathway) <- 1:nrow(pathway)
  
  # Construct node and edge list
  
  node_list <-
    data.frame(id = rownames(pathway), label = pathway$Course.Code)
  
  edge_list <- data.frame(from = NA, to = NA)
  
  for (node in node_list$label) {
    str <- subset(pathway, Course.Code == node)$Prerequisite
    course_code <- ""
    if (str != "") {
      course_code <- str_extract_all(str, "[A-Z]{4} [0-9]{3}")[[1]]
    }
    
    from <- rownames(subset(pathway, Course.Code == node))
    to <- rownames(subset(pathway, Course.Code %in% course_code))
    if (length(to) > 1) {
      for (id in to) {
        edge_list <- rbind(edge_list, data.frame(from = id, to = from))
      }
    } else {
      edge_list <- rbind(edge_list, data.frame(from = to[1], to = from))
    }
  }
  edge_list <- na.omit(edge_list)
  
  # Get structural complexity
  
  sc <- structural_complexity(edge_list, node_list)
  
  # Store in list
  results <-
    list(node_list = node_list,
         edge_list = edge_list,
         sc = sc)
  
  Gc <- c(Gc, list(results))
}
```

```{r Extract Max and Min Graphs - Minor prereq on}
# Initialize variables for maximum and minimum values
max_total <- -Inf
min_total <- Inf
max_index <- NULL
min_index <- NULL

# Iterate through Gc to find max and min indices
for (i in seq_along(Gc)) {
  total <- Gc[[i]]$sc$total
  if (total > max_total) {
    max_total <- total
    max_index <- i
  }
  if (total < min_total) {
    min_total <- total
    min_index <- i
  }
}

# Display the indices
print(paste("Index of maximum sc$total:", max_index))
print(paste("Index of minimum sc$total:", min_index))
```

#### Maximum Structural Complexity

```{r Generate Node Coords Max - Minor prereq on}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, #
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, #
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, #
    5, 0,
    5, 1,
    5, 2,
    5, 3,
    5, 4, #
    6, 0,
    6, 1,
    6, 2
))
```

```{r visualize max graph prereq on}
# node_list <- Gc[[max_index]]$node_list
# edge_list <- Gc[[max_index]]$edge_list
# 
# sc_df <- structural_complexity(edge_list,node_list)
# cf_df <- centrality_factor(edge_list,node_list)
# bf_df <- blocking_factor(edge_list,node_list)
# df_df <- delay_factor(edge_list,node_list)
# 
# node_list <- left_join(node_list, sc_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, cf_df, by = c("id" = "id"))
# node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, df_df$bynode, by = c("id" = "id"))
# max_graph <- list(edge_list = edge_list, node_list = node_list, sc_total = sc_df$total, bf_total = bf_df$total, df_total = df_df$total)
# 
# save(max_graph, file = "./maxGraph_minor.RData")

load("..\\data\\rdata\\maxGraph_minor.RData")

visNetwork(
  max_graph$node_list,
  max_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    max_graph$sc_total,
    "Total Blocking Factor:",
    max_graph$bf_total,
    "Total Delay Factor:",
    max_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Highest cruciality: STAT 230 - 116

Highest blocking factor: MATH 100 - 12

Highest delay factor: STAT 230, DATA 311, PSYO 373, DATA 410, MATH 100, MATH 101, COSC 221, PSYO 372, PSYO 270, PSYO 271, PSYO 111, PSYO 121 - 6

#### Minimum Structural Complexity

```{r Generate Node Coords Min - Minor}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, #
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4
))
```

```{r Visualize Min SC - Minor}
# node_list <- Gc[[min_index]]$node_list
# edge_list <- Gc[[min_index]]$edge_list
# 
# sc_df <- structural_complexity(edge_list,node_list)
# cf_df <- centrality_factor(edge_list,node_list)
# bf_df <- blocking_factor(edge_list,node_list)
# df_df <- delay_factor(edge_list,node_list)
# 
# node_list <- left_join(node_list, sc_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, cf_df, by = c("id" = "id"))
# node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, df_df$bynode, by = c("id" = "id"))
# min_graph <- list(edge_list = edge_list, node_list = node_list, sc_total = sc_df$total, bf_total = bf_df$total, df_total = df_df$total)
# 
# save(min_graph, file = "./mingraph_minor.RData")

load("..\\data\\rdata\\minGraph_minor.RData")


visNetwork(
  min_graph$node_list,
  min_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    min_graph$sc_total,
    "Total Blocking Factor:",
    min_graph$bf_total,
    "Total Delay Factor:",
    min_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )


```

Highest cruciality: STAT 230 - 110

Highest blocking factor: MATH 100 - 10

Highest delay factor: STAT 230, DATA 311, MATH 200, STAT 303, MATH 100, MATH 101, STAT 401, DATA 407,DATA 315, DATA 405, MATH 101 - 5

### With prereqs off
#### Setup

```{r Read in data - Minor2  prereq off}
# Read in data
ubco <- read.csv("..\\data\\UBCO\\UBCO_Course_Calendar.csv")
str(ubco)
```

```{r Generate Curriculum Graphs - Minor  prereq off}

# Create list for storing pathways
Gc <- list()

for (i in 1:1000) {
  pathway <-
    data.frame(
      Course.Code = NA,
      Course.Name = NA,
      Course.Description = NA,
      Prerequisite = NA,
      Corequisite = NA,
      Equivalents = NA
    )
  # 30 Credits from:
  
  # Required courses
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% c("DATA 101","STAT 230", "DATA 301","DATA 311")))
  
  up_to_6_creds <- c("MATH 100", "MATH 101", "MATH 200", "MATH 221", "COSC 111", "COSC 121", "COSC 221", "COSC 222", "ECON 102", "APSC", "BIOL 202", "PSYO 373", "APSC 254")
  courses <- sample(up_to_6_creds,2)
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% courses))
  
upper_year_data <-
    c("DATA 310", "DATA 315", "DATA 405", "DATA 407", "DATA 410")
  max_3_cosc <- c("COSC 304","COSC 322","COSC 329","COSC 344", "COSC 421")
  max_6_stat <- c("STAT 303","STAT 401")
  cosc_cred <- 0
  stat_cred <- 0
  total_cred <- 0
  
  while (total_cred != 12) {
    x <- sample(1:3, 1)
    
    if (x == 1 & total_cred != 12) {
      courses <- sample(upper_year_data, 1)
      if (sum(courses %in% pathway$Course.Code)==0) {
        pathway <-
          rbind(pathway, subset(ubco, Course.Code %in% courses))
        total_cred <- total_cred + 3
      }
      
    } else if (x == 2 & cosc_cred != 3) {
      courses <- sample(max_3_cosc, 1)
      if (sum(courses %in% pathway$Course.Code)==0) {
        pathway <-
          rbind(pathway, subset(ubco, Course.Code %in% courses))
        cosc_cred <- 3
        total_cred <- total_cred + 3
      }
    } else if (x == 3 & stat_cred != 6) {
      courses <- sample(max_6_stat)
      if (sum(courses %in% pathway$Course.Code)==0) {
        pathway <-
          rbind(pathway, subset(ubco, Course.Code %in% courses))
        stat_cred <- stat_cred + 3
        total_cred <- total_cred + 3
      }
    }
  }
  
  pathway <- na.omit(pathway)
  pathway <- pathway[!duplicated(pathway),]
  rownames(pathway) <- 1:nrow(pathway)
  
  # Construct node and edge list
  
  node_list <-
    data.frame(id = rownames(pathway), label = pathway$Course.Code)
  
  edge_list <- data.frame(from = NA, to = NA)
  
  for (node in node_list$label) {
    str <- subset(pathway, Course.Code == node)$Prerequisite
    course_code <- ""
    if (str != "") {
      course_code <- str_extract_all(str, "[A-Z]{4} [0-9]{3}")[[1]]
    }
    
    from <- rownames(subset(pathway, Course.Code == node))
    to <- rownames(subset(pathway, Course.Code %in% course_code))
    if (length(to) > 1) {
      for (id in to) {
        edge_list <- rbind(edge_list, data.frame(from = id, to = from))
      }
    } else {
      edge_list <- rbind(edge_list, data.frame(from = to[1], to = from))
    }
  }
  edge_list <- na.omit(edge_list)
  
  # Get structural complexity
  
  sc <- structural_complexity(edge_list, node_list)
  
  # Store in list
  results <-
    list(node_list = node_list,
         edge_list = edge_list,
         sc = sc)
  
  Gc <- c(Gc, list(results))
}
```

```{r Extract Max and Min Graphs - Minor}
# Initialize variables for maximum and minimum values
max_total <- -Inf
min_total <- Inf
max_index <- NULL
min_index <- NULL

# Iterate through Gc to find max and min indices
for (i in seq_along(Gc)) {
  total <- Gc[[i]]$sc$total
  if (total > max_total) {
    max_total <- total
    max_index <- i
  }
  if (total < min_total) {
    min_total <- total
    min_index <- i
  }
}

# Display the indices
print(paste("Index of maximum sc$total:", max_index))
print(paste("Index of minimum sc$total:", min_index))
```

#### Maximum Structural Complexity

```{r Generate Node Coords Max - Minor2}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    3, 0,
    3, 1
))
```

```{r Visualize max graph prereqs off - Minor}
#  node_list <- Gc[[max_index]]$node_list
#  edge_list <- Gc[[max_index]]$edge_list
# 
#  sc_df <- structural_complexity(edge_list,node_list)
#  cf_df <- centrality_factor(edge_list,node_list)
#  bf_df <- blocking_factor(edge_list,node_list)
#  df_df <- delay_factor(edge_list,node_list)
# 
#  node_list <- left_join(node_list, sc_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, cf_df, by = c("id" = "id"))
#  node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "id"))
#  node_list <- left_join(node_list, df_df$bynode, by = c("id" = "id"))
# max_graph <- list(edge_list = edge_list, node_list = node_list, sc_total = sc_df$total, bf_total = bf_df$total, df_total = df_df$total)
# 
# save(max_graph, file = "./max_graph_minor_prereq_off.RData")

load("..\\data\\rdata\\max_graph_minor_prereq_off.RData")


visNetwork(
  max_graph$node_list,
  max_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    max_graph$sc_total,
    "Total Blocking Factor:",
    max_graph$bf_total,
    "Total Delay Factor:",
    max_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Highest cruciality: STAT 230 - 69

Highest blocking factor: MATH 101 - 7

Highest delay factor: STAT 230, DATA 311, MATH 101, COSC 221, DATA 410 - 5

#### Minimum Structural Complexity

```{r Generate Node Coords Min - Minor prereq off}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3
))
```

```{r Visualize Min SC - Minor prereq off}
node_list <- Gc[[min_index]]$node_list
edge_list <- Gc[[min_index]]$edge_list

sc_df <- structural_complexity(edge_list,node_list)
cf_df <- centrality_factor(edge_list,node_list)
bf_df <- blocking_factor(edge_list,node_list)
df_df <- delay_factor(edge_list,node_list)

node_list <- left_join(node_list, sc_df$bynode, by = c("id" = "id"))
node_list <- left_join(node_list, cf_df, by = c("id" = "id"))
node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "id"))
node_list <- left_join(node_list, df_df$bynode, by = c("id" = "id"))
min_graph <- list(edge_list = edge_list, node_list = node_list, sc_total = sc_df$total, bf_total = bf_df$total, df_total = df_df$total)

visNetwork(
  min_graph$node_list,
  min_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    min_graph$sc_total,
    "Total Blocking Factor:",
    min_graph$bf_total,
    "Total Delay Factor:",
    min_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )


```

Highest cruciality: STAT 230 - 12

Highest blocking factor: DATA 101 - 5

Highest delay factor: DATA 101, STAT 230, DATA 311, DATA 405, DATA 315, DATA 310 - 3

## Creation of Math Stream

Including MATH 409 increases structural complexity drastically as it requires a host of pre-requisite course not already available within the Data Science major. This suggests the possibility of a mathematics stream within Data Science where 2nd and 3rd year math courses would be made mandatory. We investigate the structure of a such a program below.

```{r Generate pathway and node - MATH, cache=TRUE}
# Read in data
ubco <- read.csv("..\\data\\UBCO\\UBCO_Course_Calendar.csv")

# Create list for storing pathways
Gc <- list()

for (i in 1:1000) {
  # Generate degree pathway
  pathway <-
    data.frame(
      Course.Code = NA,
      Course.Name = NA,
      Course.Description = NA,
      Prerequisite = NA,
      Corequisite = NA,
      Equivalents = NA
    )
  
  # First Year
  pathway <- rbind(pathway, subset(ubco, Course.Code == "DATA 101"))
  samp <- sample(c("CHEM 111", "CHEM 121"), 1)
  pathway <- rbind(pathway, subset(ubco, Course.Code == samp))
  pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% c("MATH 100", "MATH 101")))
  samp <- sample(c(TRUE, FALSE), 1)
  
  if (samp) {
    pathway <- rbind(pathway, subset(ubco, Course.Code == "ENGL 109"))
  } else {
    samp <- sample(
      c(
        "ENGL 112",
        "ENGL 113",
        "ENGL 114",
        "ENGL 150",
        "ENGL 151",
        "ENGL 153",
        "ENGL 154",
        "ENGL 155",
        "ENGL 156"
      ),
      2
    )
    pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
  }
  
  
  samp <- sample(c("PHYS 111", "PHYS 112"), 1)
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
  samp <- sample(c("PHYS 121", "PHYS 122"), 1)
  pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
  pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% c("COSC 111", "COSC 121")))
  
  
  # Second Year
  pathway <-
    rbind(pathway, subset(
      ubco,
      Course.Code %in% c("MATH 200",
                         "MATH 221",
                         "STAT 230",
                         "COSC 221",
                         "COSC 222")
    ))
  
  
  # Third and Fourth Year
  pathway <-
    rbind(pathway, subset(
      ubco,
      Course.Code %in% c("DATA 301",
                         "DATA 311",
                         "COSC 304",
                         "STAT 303",
                         "PHIL 331")
    ))
  
  
  
  upper_year_data <-
    c("DATA 310", "DATA 315", "DATA 405", "DATA 407", "DATA 410")
  max_2_stat <- c("STAT 400", "STAT 401", "STAT 403", "STAT 406")
  
  upper_year_math <-
    c(
      "MATH 409",
      "MATH 303",
      "MATH 307",
      "MATH 319",
      "MATH 225"
    )
  course <- c()
  while (length(unique(course)) < 4) {
    var <- sample(1:2, 1)
    
    if (var == 1) {
      course <- c(course, sample(max_2_stat, 1))
    } else if (var == 2) {
      course <- c(course, sample(upper_year_data, 1))
    }
  }
  
  pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% c(unique(course),upper_year_math)))
  
  pathway <- na.omit(pathway)
  # pathway <- pathway[!duplicated(pathway),]
  rownames(pathway) <- 1:nrow(pathway)
  
  # Construct node and edge list
  
  node_list <-
    data.frame(id = rownames(pathway), label = pathway$Course.Code)
  
  edge_list <- data.frame(from = NA, to = NA)
  
  for (node in node_list$label) {
    str <- subset(pathway, Course.Code == node)$Prerequisite
    course_code <- ""
    if (str != "") {
      course_code <- str_extract_all(str, "[A-Z]{4} [0-9]{3}")[[1]]
    }
    
    from <- rownames(subset(pathway, Course.Code == node))
    to <- rownames(subset(pathway, Course.Code %in% course_code))
    if (length(to) > 1) {
      for (id in to) {
        edge_list <- rbind(edge_list, data.frame(from = id, to = from))
      }
    } else {
      edge_list <- rbind(edge_list, data.frame(from = to[1], to = from))
    }
  }
  edge_list <- na.omit(edge_list)
  
  # Get structural complexity
  
  sc <- structural_complexity(edge_list, node_list)
  
  # Store in list
  results <-
    list(node_list = node_list,
         edge_list = edge_list,
         sc = sc)
  
  Gc <- c(Gc, list(results))
}
```

```{r Extract Max and Min Graphs - MATH}
# Initialize variables for maximum and minimum values
max_total <- -Inf
min_total <- Inf
max_index <- NULL
min_index <- NULL

# Iterate through Gc to find max and min indices
for (i in seq_along(Gc)) {
  total <- Gc[[i]]$sc$total
  if (total > max_total) {
    max_total <- total
    max_index <- i
  }
  if (total < min_total) {
    min_total <- total
    min_index <- i
  }
}

# Display the indices
print(paste("Index of maximum sc$total:", max_index))
print(paste("Index of minimum sc$total:", min_index))
```

### Maximum Structural Complexity

```{r Generate Node Coords Max - MATH}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, #
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, #
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, #
    5, 0,
    5, 1,
    5, 2,
    5, 3,
    5, 4, #
    6, 0,
    6, 1,
    6, 2,
    6, 3
))
```


```{r Visualize Max SC - MATH}
# node_list <- Gc[[max_index]]$node_list
# edge_list <- Gc[[max_index]]$edge_list
# 
# sc_df <- structural_complexity(edge_list,node_list)
# cf_df <- centrality_factor(edge_list,node_list)
# bf_df <- blocking_factor(edge_list,node_list)
# df_df <- delay_factor(edge_list,node_list)
# 
# node_list <- left_join(node_list, sc_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, cf_df, by = c("id" = "id"))
# node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, df_df$bynode, by = c("id" = "id"))
# max_graph <- list(edge_list = edge_list, node_list = node_list, sc_total = sc_df$total, bf_total = bf_df$total, df_total = df_df$total)
# 
#  save(max_graph, file = "./maxGraph_math.RData")

load("..\\data\\rdata\\maxGraph_math.RData")

visNetwork(
  max_graph$node_list,
  max_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    max_graph$sc_total,
    "Total Blocking Factor:",
    max_graph$bf_total,
    "Total Delay Factor:",
    max_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Highest centrality: STAT 230 (116), MATH 101 (104)

Highest cruciality: MATH 100 (23), MATH 101 (19)

Highest blocking factor: MATH 100 (17), MATH 101 (13)

Highest delay factor: MATH 100, MATH 101, STAT 230, COSC 221, DATA 311, DATA 410(6)


```{r printing max graph metrics - MATH}
kable(max_graph$node_list)
```

### Minimum Structural Complexity

```{r Generate Node Coords Min - MATH}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, 
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, 
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, 
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, 
    5, 0,
    5, 1,
    5, 2,
    5, 3, 
    6, 0,
    6, 1,
    6, 2, 
    6, 3 
))
```

```{r Visualize Min SC - MATH}
# node_list <- Gc[[min_index]]$node_list
# edge_list <- Gc[[min_index]]$edge_list
# 
# sc_df <- structural_complexity(edge_list,node_list)
# cf_df <- centrality_factor(edge_list,node_list)
# bf_df <- blocking_factor(edge_list,node_list)
# df_df <- delay_factor(edge_list,node_list)
# 
# node_list <- left_join(node_list, sc_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, cf_df, by = c("id" = "id"))
# node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "id"))
# node_list <- left_join(node_list, df_df$bynode, by = c("id" = "id"))
# 
# min_graph <- list(edge_list = edge_list, node_list = node_list, sc_total = sc_df$total, bf_total = bf_df$total, df_total = df_df$total)
# 
# save(min_graph, file = "./minGraph_math.RData")

load("../data/rdata/minGraph_math.RData")

visNetwork(
  min_graph$node_list,
  min_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    min_graph$sc_total,
    "Total Blocking Factor:",
    min_graph$bf_total,
    "Total Delay Factor:",
    min_graph$df_total
  )
) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Highest centrality: MATH 101 (79), STAT 230 (66)

Highest cruciality: MATH 100 (21), MATH 101 (17)

Highest blocking factor: MATH 100 (16), MATH 101 (12)

Highest delay factor: MATH 100, MATH 101, MATH 200, STAT 230, COSC 221, DATA 311, STAT 303, STAT 403, STAT 406, DATA 407, MATH 319, MATH 225 (5)

```{r printing min graph metrics - MATH}
kable(min_graph$node_list)
```

The difference in elective coruses that caused the total metric scores to be so different are given below.

The courses in the max graph that are not found in the min graph are:

```{r Printing max graph unique courses - MATH}
idx <- !(max_graph$node_list$label %in% min_graph$node_list$label)
kable(max_graph$node_list$label[idx])
```

The courses in the min graph that are not found in the max graph are:

```{r Printing min graph unique courses - MATH}
idx <- !(min_graph$node_list$label %in% max_graph$node_list$label)
kable(min_graph$node_list$label[idx])
```







## References

::: {#refs}
:::



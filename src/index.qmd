---
title: "UBCO-Curriucla-Analysis"
format: html
bibliography: references.bib
output-dir: ./docs
---
## Introduction to Network Analysis

A nice introduction to Network Analysis in R is given [here](https://www.jessesadler.com/post/network-analysis-with-r/)

The major players in the network analysis space for R are the Statnet packages, tidygraph, igrpah. Interactive graphs can be created with the vizNetowrk and networkD3 packages. For an example of the some of the interactive visualizations we could make look [here](https://christophergandrud.github.io/networkD3/). There is also plenty of support for these visualization in Shiny so we do we eventually make a dashboard style took these will make an easy addition.

Next I follow the tutorial by Jesse Sadler to introduce working with networks in R.

Generally to create graphs you will need an adjacency matrix (for the network, igraph, and tidygraph packages) or an edge-list data frame for the tidyverse workflow. Edge-list dataframes can be converted to adjacency matrix and so we opt for their creation when doing network analysis.

Edge-list data frames have at least two columns: "from" and "to" columns for describing connections between nodes. Other columns may be added to describes attributes of nodes or weights for edges. Each node requires a unique identifier, generally an integer. An example Edge-list data frame:

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, cache = TRUE)
```

```{r}
# Load libraries
library(tidyverse)
library(network)
library(tidygraph)
library(ggraph)
library(visNetwork)
library(networkD3)
library(dplyr)
library(docstring)
```


```{r}
edge_list <- tibble(from = c(1, 2, 2, 3, 4), to = c(2, 3, 4, 2, 1))
node_list <- tibble(id = 1:4, label = paste("node ", seq(1, 4)))

edge_list
node_list
```
Let's explore the various packages.

### network

We create a network object from the edge list.

```{r}


network <- network(
    edge_list,
    vertex.attr = node_list,
    matrix.type = "edgelist",
    ignore.eval = TRUE
)
network
```

Then we can visualize the graph. THe mode argument will use different algorithms to plot the graph.

```{r}
plot(network, vertex.cex = 4, mode = "circle")
```

### igraph

You need to remove the network package because there is a lot of overlap in the name space.

```{r}
# Detatch network and load igraph
detach(package:network)
rm(network)
library(igraph)
```
We need to convert our edge list to a form usable by igraph.

```{r}
network <- graph_from_data_frame(
    d = edge_list,
    vertices = node_list,
    directed = TRUE
)

network
```
The information for the graph description is shorthand for a few things. D is directed, N says we have a name attribute, the first - means not weight weighted, the second - means not bipartite, 4 is the number of nodes, 5 is the number of edges, attr tells use there are two node attributes, and a print out of all edges. We can also plot this graph and again layout is an argument to control the algorithm for plotting the network.

```{r}
plot(network,
    layout = layout_with_graphopt,
    vertex.size = 30,
    vertex.label.cex = 1,
    edge.arrow.size = 0.8
)
```
### tidygraph and ggraph

If we want to leverage the tidyverse workflow and ggplot we can use the tidygraph package. We first need to make a tbl_graph object.

```{r}


network_tbl <- tbl_graph(
    nodes = node_list,
    edges = edge_list,
    directed = TRUE
)
network_tbl
```
The output states Node Data is active. This means if you manipulate data in this object it will manipulate the Node Data table. Use the activate() function to switch to the other table in the object. Now we can plot our network in a ggplot style.

```{r}
ggraph(network_tbl, layout = "graphopt") +
    geom_node_point() +
    geom_edge_link() +
    geom_node_text(aes(label = label), repel = TRUE) +
    theme_graph()
```

You can also make arc graphs.

```{r}
ggraph(network_tbl, layout = "linear") +
    geom_edge_arc(alpha = 0.8) +
    scale_edge_width(range = c(0.2, 2)) +
    geom_node_text(aes(label = label)) +
    labs() +
    theme_graph()
```

### Interactive visualizations

It is quite easy to turn our previously static graphs into interactive visualizations. [visNetwork](https://datastorm-open.github.io/visNetwork/) uses JavaScript to create these visualizations and has create documentation for increasing the interactivity of our graphs. We will use this visualization package for our analysis. Others however do exist like networkD3.

```{r, warning=FALSE}


visNetwork(node_list, edge_list) %>%
    visEdges(arrows = "middle")
```


## Curricular Analytics

### Background

The following is adapted from [@heileman2018curricular].

Curriculum is modeled as a *directed acyclic graph* (DAG) where courses are nodes and requisite relationships between nodes are directed edges. Mathematically a *curriculum graph* is denoted $G_c = V(V,E)$ where $v_1,\dots,v_n \in V$ are courses and the directed edge $(v_i,v_j) \in E$ is a requisite from $v_i$ to $v_j$ that must be completed before enrollment in $v_j$. Nodes in these graph are organized in columns representing each term in a curriculum. Edges down columns are co-requisites and edges across columns are pre-requisites.

With this framework of modeling comes a host of useful metrics for gaining insight about a curriculum graph's structure. Next we outline a few of the metrics and provide functions for calculating them.

First we construct a graph to showcase the metrics.

```{r}
edge_list <- tibble(from = c(1, 2, 1), to = c(2, 4, 3))
node_list <- tibble(id = as.character(1:4), label = paste0("v", seq(1, 4)))

coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    2, 0,
    2, 1,
    3, 0
))

visNetwork(node_list, edge_list) %>%
    visEdges(arrows = "middle") %>%
    visIgraphLayout(layout = "layout.norm", layoutMatrix = coords)
```

#### Delay Factor

*Delay factor* is a metric used to quantify the existent of long pathways through a curriculum graph. These longs paths indicate a chain of requisite relationships where if w a student were to fail a given course along the path they would suffer a heavily delayed graduation. The delay factor for a given node is the number of vertices ih the longest path of $G_c$ that contains the given node.

```{r Define delay factor}
 delay_factor <- function(edge_list,node_list){
#' Delay factor
#'
#' Calculates the delay factor for each node and the total delay factor of the curriculum graph. Delay factor is defined as the number of vertices in the longest path in G that pass through v. The function returns a list where bynode holds the delay factor for each node and total holds the delay factor for the graph.
#'
#' @param edge_list data frame containing the edge list of the graph.
#' @param node_list data frame containing the node list of the graph.

bynode <- data.frame(id = NA, df = NA)

network <- graph_from_data_frame(
    d = edge_list,
    vertices = node_list,
    directed = TRUE
)
paths <- list()

for (v in as.numeric(node_list$id)) {
    paths <- c(paths, all_simple_paths(network, from = v, mode = "out"))
}

for (v in as.numeric(node_list$id)) {
    max_length <- 0
    for (path in paths) {
        if (v %in% as.vector(path) && max_length < length(as.vector(path))) {
            max_length <- length(as.vector(path))
        }
    }

    bynode <- rbind(bynode, data.frame(id = as.character(v), df = max_length))
   
}

 bynode <- na.omit(bynode)
 total <- sum(bynode$df)
 
 list(bynode = bynode, total = total)
 }
```

```{r}
df_df <- delay_factor(edge_list,node_list)
df <- df_df$bynode



node_list <- left_join(node_list, df, by = c("id" = "id"))


network <- graph_from_data_frame(
    d = edge_list,
    vertices = node_list,
    directed = TRUE
)

visNetwork(node_list, edge_list, 
           submain = list(text = paste("Total df:",df_df$total))) %>%
    visEdges(arrows = "middle") %>%
    visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
    visEvents(selectNode = "function(properties) {
      alert(' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}")
```



### Analysis

Our data set consists of course information from the data science program at UBCO. We have course codes, names, descriptions, and requisite relationships. 

```{r}
# Read in data
ubco <- read.csv("..\\data\\UBCO\\UBCO_Course_Calendar.csv")
str(ubco)
```

With this we can construct degree pathways through our curriculum and graph them. Since there are many electives within our program there are many possible curriculum graphs.

```{r}
# Set seed
set.seed(8746)

# Generate degree pathway
pathway <-
    data.frame(
        Course.Code = NA,
        Course.Name = NA,
        Course.Description = NA,
        Prerequisite = NA,
        Corequisite = NA,
        Equivalents = NA
    )

# First Year
pathway <- rbind(pathway, subset(ubco, Course.Code == "DATA 101"))
samp <- sample(c("CHEM 111", "CHEM 121"), 1)
pathway <- rbind(pathway, subset(ubco, Course.Code == samp))
pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% c("MATH 100", "MATH 101")))
samp <- sample(c(TRUE, FALSE), 1)


if (samp) {
    pathway <- rbind(pathway, subset(ubco, Course.Code == "ENGL 109"))
} else {
    samp <- sample(
        c(
            "ENGL 112",
            "ENGL 113",
            "ENGL 114",
            "ENGL 150",
            "ENGL 151",
            "ENGL 153",
            "ENGL 154",
            "ENGL 155",
            "ENGL 156"
        ),
        2
    )
    pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
}

samp <- sample(c("PHYS 111", "PHYS 112"), 1)
pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
samp <- sample(c("PHYS 121", "PHYS 122"), 1)
pathway <- rbind(pathway, subset(ubco, Course.Code %in% samp))
pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% c("COSC 111", "COSC 121")))


# Second Year
pathway <-
    rbind(pathway, subset(
        ubco,
        Course.Code %in% c(
            "MATH 200",
            "MATH 221",
            "STAT 230",
            "COSC 221",
            "COSC 222"
        )
    ))


# Third and Fourth Year
pathway <-
    rbind(pathway, subset(
        ubco,
        Course.Code %in% c(
            "DATA 301",
            "DATA 311",
            "COSC 304",
            "STAT 303",
            "PHIL 331"
        )
    ))



upper_year_data <-
    c("DATA 310", "DATA 315", "DATA 405", "DATA 407", "DATA 410")
max_2_stat <- c("STAT 400", "STAT 401", "STAT 403", "STAT 406")
max_2_cosc_math_phys <-
    c(
        "COSC 303",
        "COSC 322",
        "COSC 329",
        "COSC 344",
        "COSC 407",
        "COSC 421",
        "MATH 303",
        "MATH 307",
        "MATH 409",
        "PHYS 420"
    )
course <- c()
while (length(unique(course)) < 9) {
    var <- sample(c("1", "2", "3"), 1)

    if (var == 1) {
        course <- c(course, sample(max_2_stat, 1))
    } else if (var == 2) {
        course <- c(course, sample(max_2_cosc_math_phys, 1))
    } else if (var == 3) {
        course <- c(course, sample(upper_year_data, 1))
    }
}

pathway <-
    rbind(pathway, subset(ubco, Course.Code %in% unique(course)))

pathway <- na.omit(pathway)
rownames(pathway) <- 1:nrow(pathway)

head(pathway)
```

After generating a student's path through our program we generate the node and edge lists.

```{r}
# Construct node and edge list

node_list <-
    data.frame(id = rownames(pathway), label = pathway$Course.Code)

edge_list <- data.frame(from = NA, to = NA)

node <- "DATA 410"

for (node in node_list$label) {
    str <- subset(pathway, Course.Code == node)$Prerequisite
    course_code <- ""
    if (str != "") {
        course_code <- str_extract_all(str, "[A-Z]{4} [0-9]{3}")[[1]]
    }

    from <- rownames(subset(pathway, Course.Code == node))
    to <- rownames(subset(pathway, Course.Code %in% course_code))
    if (length(to) > 1) {
        for (id in to) {
            edge_list <- rbind(edge_list, data.frame(from = id, to = from))
        }
    } else {
        edge_list <- rbind(edge_list, data.frame(from = to[1], to = from))
    }
}
edge_list <- na.omit(edge_list)
```

By default visNetwork will randomly places nodes all over the place. Therefore we specify a coordinate list to get the term structure outlined in [@heileman2018curricular].

```{r}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4,
    1, 5,
    1, 6,
    1, 7,
    1, 8,
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4,
    2, 5,
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4,
    3, 5,
    3, 6,
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4,
    4, 5,
    4, 6
))
```

I would also like the various metrics for each node to be displayed when clicking on them to facilitate the analysis. There is no R package for Curricular Analytics so I have code the metrics myself.

```{r Metric Functions}
# TODO work in progress

# TODO currently calculates longest path with given node as the root. Therefore peripheriy nodes get a df of 1 when it should be more
# delay factor - number of vertices in the longest path in G that pass through v
delay_factor <- function(network) {
    delay_factor <- data.frame(name = NA, df = NA)

    # extract node list
    node_list <- as_data_frame(network, what = "vertices")

    # for each node in node list
    for (v in node_list$name) {
        dists <-
            distances(network, v = v, mode = "out") # find distances to all other nodes
        idx <- is.finite(dists)
        dists <- dists[idx]
        df <- max(dists) + 1 # add 1 to make it a node count
        delay_factor <-
            rbind(delay_factor, data.frame(name = v, df = df))
    }
    delay_factor <-
        na.omit(delay_factor) # return delay factors of each node
    list(bynode = delay_factor, total = sum(delay_factor$df))
}

# blocking factor - number of nodes blocked by a given nodes
# TODO also doesn't work right seems to be off by 1 each time
blocking_factor <- function(network) {
    blocking_factor <- data.frame(name = NA, bf = NA)

    # extract node list
    node_list <- as_data_frame(network, what = "vertices")

    for (v in node_list$name) {
        bf <- length(na.omit(bfs(network, v, unreachable = F)$order)) - 1
        blocking_factor <-
            rbind(blocking_factor, data.frame(name = v, bf = bf))
    }

    blocking_factor <- na.omit(blocking_factor)
    list(bynode = blocking_factor, total = sum(blocking_factor$bf))
}

# reachability factor - number of courses that must be completed before one would be allowed to take a given course
reachability_factor <- function(network) {
    reachability_factor <- data.frame(name = NA, rf = NA)

    # extract node list
    node_list <- as_data_frame(network, what = "vertices")

    for (v in node_list$name) {
        rf <- length(na.omit(dfs(network, v, unreachable = F, mode = "out")$order)) - 1
        reachability_factor <-
            rbind(reachability_factor, data.frame(name = v, rf = rf))
    }

    reachability_factor <- na.omit(reachability_factor)
    list(bynode = reachability_factor, total = sum(reachability_factor$rf))
}
```

Now we call my functions on our network object, calculate the metrics and  join the resulting tables to our node_list.

```{r}


network <- graph_from_data_frame(
    d = edge_list,
    vertices = node_list,
    directed = TRUE
)

df_df <- delay_factor(network)
bf_df <- blocking_factor(network)
rf_df <- reachability_factor(network)

node_list <- left_join(node_list, df_df$bynode, by = c("id" = "name"))
node_list <- left_join(node_list, bf_df$bynode, by = c("id" = "name"))
node_list <- left_join(node_list, rf_df$bynode, by = c("id" = "name"))

network <- graph_from_data_frame(
    d = edge_list,
    vertices = node_list,
    directed = TRUE
)

```

Finally we make the graph visualization. I have specified a custom viSEvents function so that upon clicking a node the metrics are displayed. Just as a note visEvents needs to be written in JavaScript and to see what is possible view the documentation.

```{r}
# node_list$label <- paste(node_list$label,node_list$id)

# Generate Curriculum Graph
visNetwork(node_list, edge_list) %>%
    visEdges(arrows = "middle") %>%
    visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
    visEvents(selectNode = "function(properties) {
      alert('id: ' + this.body.data.nodes.get(properties.nodes[0]).id + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf+ ' rf: ' + this.body.data.nodes.get(properties.nodes[0]).rf);}")
```

## References

::: {#refs}
:::



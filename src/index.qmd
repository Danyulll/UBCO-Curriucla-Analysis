---
title: "UBCO-Curriucla-Analysis"
format: html
bibliography: references.bib
output-dir: ./docs
---
## Introduction to Network Analysis in R

A nice introduction to Network Analysis in R is given [here](https://www.jessesadler.com/post/network-analysis-with-r/)

The major players in the network analysis space for R are the Statnet packages, tidygraph, igrpah. Interactive graphs can be created with the vizNetowrk and networkD3 packages. For an example of the some of the interactive visualizations we could make look [here](https://christophergandrud.github.io/networkD3/). There is also plenty of support for these visualization in Shiny so we do we eventually make a dashboard style took these will make an easy addition.

Next I follow the tutorial by Jesse Sadler to introduce working with networks in R.

Generally to create graphs you will need an adjacency matrix (for the network, igraph, and tidygraph packages) or an edge-list data frame for the tidyverse workflow. Edge-list dataframes can be converted to adjacency matrix and so we opt for their creation when doing network analysis.

Edge-list data frames have at least two columns: "from" and "to" columns for describing connections between nodes. Other columns may be added to describes attributes of nodes or weights for edges. Each node requires a unique identifier, generally an integer. An example Edge-list data frame:

```{r Setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(message = FALSE, warning = FALSE, cache = TRUE)
```

```{r Load libraries}
# Load libraries
library(tidyverse)
library(network)
library(tidygraph)
library(ggraph)
library(visNetwork)
library(networkD3)
library(dplyr)
library(docstring)
```


```{r Edge and Node List Example}
edge_list <- tibble(from = c(1, 2, 2, 3, 4), to = c(2, 3, 4, 2, 1))
node_list <- tibble(id = 1:4, label = paste("node ", seq(1, 4)))

edge_list
node_list
```
Let's explore the various packages.

### network

We create a network object from the edge list.

```{r Network Object Example}
network <- network(
  edge_list,
  vertex.attr = node_list,
  matrix.type = "edgelist",
  ignore.eval = TRUE
)
network
```

Then we can visualize the graph. THe mode argument will use different algorithms to plot the graph.

```{r Plotting Network Example}
plot(network, vertex.cex = 4, mode = "circle")
```

### igraph

You need to remove the network package because there is a lot of overlap in the name space.

```{r Igraph Example}
# Detatch network and load igraph
detach(package:network)
rm(network)
library(igraph)
```
We need to convert our edge list to a form usable by igraph.

```{r Igraph Network Object Example}
network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)
network
```
The information for the graph description is shorthand for a few things. D is directed, N says we have a name attribute, the first - means not weight weighted, the second - means not bipartite, 4 is the number of nodes, 5 is the number of edges, attr tells use there are two node attributes, and a print out of all edges. We can also plot this graph and again layout is an argument to control the algorithm for plotting the network.

```{r Ploting Igraph Example}
plot(
  network,
  layout = layout_with_graphopt,
  vertex.size = 30,
  vertex.label.cex = 1,
  edge.arrow.size = 0.8
)
```
### tidygraph and ggraph

If we want to leverage the tidyverse workflow and ggplot we can use the tidygraph package. We first need to make a tbl_graph object.

```{r Tidygraph Example}
network_tbl <- tbl_graph(nodes = node_list,
                         edges = edge_list,
                         directed = TRUE)
network_tbl
```
The output states Node Data is active. This means if you manipulate data in this object it will manipulate the Node Data table. Use the activate() function to switch to the other table in the object. Now we can plot our network in a ggplot style.

```{r Making ggraph Example}
ggraph(network_tbl, layout = "graphopt") +
  geom_node_point() +
  geom_edge_link() +
  geom_node_text(aes(label = label), repel = TRUE) +
  theme_graph()
```

You can also make arc graphs.

```{r Arc Graph Example}
ggraph(network_tbl, layout = "linear") +
    geom_edge_arc(alpha = 0.8) +
    scale_edge_width(range = c(0.2, 2)) +
    geom_node_text(aes(label = label)) +
    labs() +
    theme_graph()
```

### Interactive visualizations

It is quite easy to turn our previously static graphs into interactive visualizations. [visNetwork](https://datastorm-open.github.io/visNetwork/) uses JavaScript to create these visualizations and has create documentation for increasing the interactivity of our graphs. We will use this visualization package for our analysis. Others however do exist like networkD3.

```{r Interactive Viz Example, warning=FALSE}
visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle")
```


## Curricular Analytics

The following is adapted from [@heileman2018curricular].

Curriculum is modeled as a *directed acyclic graph* (DAG) where courses are nodes and requisite relationships between nodes are directed edges. Mathematically a *curriculum graph* is denoted $G_c = V(V,E)$ where $v_1,\dots,v_n \in V$ are courses and the directed edge $(v_i,v_j) \in E$ is a requisite from $v_i$ to $v_j$ that must be completed before enrollment in $v_j$. Nodes in these graph are organized in columns representing each term in a curriculum. Edges down columns are co-requisites and edges across columns are pre-requisites.

With this framework of modeling comes a host of useful metrics for gaining insight about a curriculum graph's structure. Next we outline a few of the metrics and provide functions for calculating them.

First we construct a graph to showcase the metrics.

```{r Example Graph to Showcase CA Metrics}
edge_list <- tibble(from = c(1, 2, 1), to = c(2, 4, 3))
node_list <-
  tibble(id = as.character(1:4), label = paste0("v", seq(1, 4)))

coords <- matrix(ncol = 2,
                 byrow = T,
                 data = c(1, 0,
                          2, 0,
                          2, 1,
                          3, 0))

visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords)
```

### Delay Factor

*Delay factor* is a metric used to quantify the existent of long pathways through a curriculum graph. These longs paths indicate a chain of requisite relationships where if w a student were to fail a given course along the path they would suffer a heavily delayed graduation. The delay factor for a given node is the number of vertices in the longest path of $G_c$ that contains the given node. An isolated node's delay factor is defined to be 1 and means it can be taken in any term. We also calculate the total delay factor for $G_c$ as the sum of all delay factors in the graph.

```{r Define delay factor}
delay_factor <- function(edge_list, node_list) {
  #' Delay factor
  #'
  #' Calculates the delay factor for each node and the total delay factor of the curriculum graph. Delay factor is defined as the number of vertices in the longest path in G that pass through v. The function returns a list where bynode holds the delay factor for each node and total holds the delay factor for the graph.
  #'
  #' @param edge_list data frame containing the edge list of the graph.
  #' @param node_list data frame containing the node list of the graph.
  
  bynode <- data.frame(id = NA, df = NA)
  
  network <- graph_from_data_frame(d = edge_list,
                                   vertices = node_list,
                                   directed = TRUE)
  paths <- list()
  
 
  for (v in as.numeric(node_list$id)) {
    paths <- c(paths, all_simple_paths(network, from = v, mode = "out"))
  }
  
  for (v in as.numeric(node_list$id)) {
    max_length <- 0
    for (path in paths) {
      if (v %in% as.vector(path) &&
          max_length < length(as.vector(path))) {
        max_length <- length(as.vector(path))
      }
    }
    
    if (max_length == 0) {
      max_length <- 1
    }
    bynode <-
      rbind(bynode, data.frame(id = as.character(v), df = max_length))
    
  }
  
  bynode <- na.omit(bynode)
  total <- sum(bynode$df)
  
  list(bynode = bynode, total = total)
}
```

```{r Visualize example delay factor}
df_df <- delay_factor(edge_list, node_list)
df <- df_df$bynode



node_list <- left_join(node_list, df, by = c("id" = "id"))


network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)

visNetwork(node_list, edge_list,
           submain = list(text = paste("Total df:", df_df$total))) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(selectNode = "function(properties) {
      alert(' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}")
```

### Blocking Factor

*Blocking factor* is a quantity that captures a course's ability to gatekeep other courses. That is, if you fail a course with a high blocking factor you are blocked from taking many other courses. The blocking factor of a node is the number of nodes reachable from the given node. The total blocking factor of the graph is the sum of all individual blocking factors.

```{r Define blocking factor}
blocking_factor <- function(edge_list, node_list) {
  #' Blocking factor
  #'
  #' Calculates the blocking factor for each node and the total blocking factor of the curriculum graph. The blocking factor of a node v is the number of nodes reachable from v. The function returns a list where bynode holds the blocking factor for each node and total holds the blocking factor for the graph.
  #'
  #' @param edge_list data frame containing the edge list of the graph.
  #' @param node_list data frame containing the node list of the graph.
  
  bynode <- data.frame(id = NA, bf = NA)
  
  network <- graph_from_data_frame(d = edge_list,
                                   vertices = node_list,
                                   directed = TRUE)
  paths <- list()

  for (v in as.numeric(node_list$id)) {
    paths <- c(paths, all_simple_paths(network, from = v, mode = "out"))
  }
  
  
  for (v in as.numeric(node_list$id)) {
    nodes_reachable <- c()
    for (path in paths) {
      curr_path <- as.vector(path)
      if (v %in% curr_path[1]) {
        nodes_reachable <- c(nodes_reachable, curr_path)
      }
    }
    
    nodes_reachable <- unique(nodes_reachable)
    nodes_reachable <- nodes_reachable[nodes_reachable != v]
    
    bynode <-
      rbind(bynode, data.frame(id = as.character(v), bf = length(nodes_reachable)))
  }
  
  bynode <- na.omit(bynode)
  
  list(bynode = bynode, total = sum(bynode$bf))
  
}
```

```{r Visualize example blocking factor}
bf_df <- blocking_factor(edge_list, node_list)
bf <- bf_df$bynode

node_list <- left_join(node_list, bf, by = c("id" = "id"))


network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)

visNetwork(node_list, edge_list,
           submain = list(text = paste("Total bf:", bf_df$total))) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(selectNode = "function(properties) {
      alert(' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf);}")
```

### Centrality Factor

*Centrality factor* indicates how central a node is to a curriculum. A node is considered central if it requires many pre-requisite courses and is itself a pre-requisite to many courses. Heileman et al. says in curricular analytics we are greatly interested in how learning outcomes achieved in one course are used in later courses and we therefore wish to identify key central courses in these paths [-@heileman2018curricular]. The centrality factor is meant to capture this and is defined as the number of nodes in all long paths that include the given node. A long path is defined to be a path with length greater than or equal to 3. Nodes who only fall on paths shorter than this are given a centrality of 0.

```{r Define centrality factor}
centrality_factor <- function(edge_list, node_list) {
  #' Centrality factor
  #'
  #' Calculates the centrality factor for each node. The centrality factor of a node v is the number of long paths containing v where a long path is one of length 3 or greater. The function returns a dataframe that holds the centrality factor for each node.
  #'
  #' @param edge_list data frame containing the edge list of the graph.
  #' @param node_list data frame containing the node list of the graph.
  
  bynode <-
    data.frame(id = as.numeric(node_list$id), cf = rep(0, length(node_list$id)))
  
  network <- graph_from_data_frame(d = edge_list,
                                   vertices = node_list,
                                   directed = TRUE)
  paths <- list()

  for (v in as.numeric(node_list$id)) {
    paths <- c(paths, all_simple_paths(network, from = v, mode = "out"))
  }
  
  for (path in paths) {
    curr_path <- as.vector(path)
    if (length(curr_path) >= 3) {
      long_path_nodes <- curr_path[c(-1, -length(curr_path))]
      
      for (node in long_path_nodes) {
        bynode[node, c("cf")] <- bynode[node, c("cf")] + length(curr_path)
      }
    }
  }
  
  bynode$id <- as.character(bynode$id)
  bynode
}
```

```{r Visualize example centrality factor}
cf <- centrality_factor(edge_list, node_list)

node_list <- left_join(node_list, cf, by = c("id" = "id"))


network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)

visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(selectNode = "function(properties) {
      alert(' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf);}")
```

### Structural Complexity and Course Cruciality
*Structural Complexity* is a metric that assess the impact that curricular structure will have on a student's journey through a curriculum. In simulations it was find that a high structural complexity correlated to decreased graduation rates. The structural complexity for a given graph is the sum of all nodes' crucialities. Cruciality is simply a linear combination of a given node's delay and blocking factors.

```{r Define structural complexity}
structural_complexity <- function(edge_list, node_list) {
  #' Structural Complexity
  #'
  #' Calculates the cruciality for each node and the structural complexity for the entire curriculum graph. The structural complexity is the sum of all node crucialities.The function returns a list where bynode holds the cruciality for each node and total holds the structural complexity for the graph.
  #'
  #' @param edge_list data frame containing the edge list of the graph.
  #' @param node_list data frame containing the node list of the graph.
  
  
  bf_df <- blocking_factor(edge_list, node_list)
  bf <- bf_df$bynode$bf
  
  df_df <- delay_factor(edge_list, node_list)
  df <- df_df$bynode$df
  
  bynode <- data.frame(id = node_list$id, sc = (bf + df))
  
  list(bynode = bynode, total = sum(bynode$sc))
  
}
```


```{r Visualize example structural complexity}
edge_list <- tibble(from = c(1, 1, 1, 3), to = c(2, 3, 4, 5))
node_list <-
  tibble(id = as.character(1:5), label = paste0("v", seq(1, 5)))

coords <- matrix(
  ncol = 2,
  byrow = T,
  data = c(1, 0,
           2, 0,
           2, 1,
           2, 2,
           3, 0)
)


sc <- structural_complexity(edge_list, node_list)$bynode

node_list <- left_join(node_list, sc, by = c("id" = "id"))


network <- graph_from_data_frame(d = edge_list,
                                 vertices = node_list,
                                 directed = TRUE)

visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc);}")
```


## Bayesian Networks

*Bayesian Networks* (BNs) are a machine learning model that in the context of curricular analytics can be used for knowledge discovery and lowering the structural complexity of a curriculum graph [@slim2021restructuring]. Slim et al. showcased the use of BNs in curricula graphs as a means to statistically validate the restructuring of university programs through discovering latent nodes in the graph evaluating them using a likelihood-ratio test. They further mention the model's capability to be used in the prediction of student grades.

BNs have much support within R and the text *Bayesian Networks in R* provides a good introduction to many of the concepts used in this analysis [@nagarajan2013bayesian].

### Background

Explanations and examples are adapted from [@scutari2009learning].

Bayesian networks utilize DAGs to model a set of random variables, i.e., for the set $\mathbf{X}=\{X_1,\dots,X_p\}$ of random variables the DAG $G=(\mathbf{V},\mathbf{A})$ is constructed where $v_i \in \mathbf{V}$ corresponds to a random variable from our set $\mathbf{X}$ and $\mathbf{A}$ is the set of arcs (edges).

The DAG itself is a factorization of the joint probability distribution of $\mathbf{V}$. This factorization follows from the Markov property of Bayesian networks: every random variable $X_i$ directly depends only on its parents $\Pi_{X_i}$ or

$$P(X_1,\dots,X_v)=\prod^v_{i=1}P(X_i|\Pi_{X_i})\text{ (for discrete variables)}$$

probability distributions exist for each node as a result of this factorization, called *local probability distributions*. The joint probability distribution for all nodes is called the *global probability distribution*.

Bayesian network model selection is done through learning the graphical structure of a Bayesian network and then estimating the parameters of the local distribution functions. It is most common to assume the local distributions are multinomial for discrete data which fits our use case. Therefore for our use case we will have a data set of courses and grades that students got. The model will then learn casual relationships between courses and the resulting grades. For example perhaps the algorithm will learn that a high grade in MATH 100 is casually related to a high grade in MATH 101. Furthermore, a benefit of these models is we may include demographic or other information and see how these casually impact grades.

There are various algorithms to learn the structure of the BN however we opt to use *hill climbing greedy search* (hc) as done in [@slim2021restructuring]. For further information on what this algorithm does see [@scutari2009learning] and [@daly2007methods]. The general idea is that hc will use some score function while investigating candidate Bayesian networks and select the one that maximizes some set heuristic. As we are working with discrete data the heuristics available to us are the *likelihood*, *Akaike Information Criterion* (AIC), *Bayesian Information Criterion* (BIC), *Bayesian Dirichelt equivalent score* (BDE), and the *K2 score*.

[@slim2021restructuring] further showcases how one may learn the structure of a BN and calculate the likelihood of the model, then add a hidden node and calculate the new likelihood, and finally conduct a likelihood-ratio test to see if the model has improved. If the model has improved, the newly added node represents a potential course that could be included in the curriculum to reduce structural complexity and improve student performance. Note there won't be grade data for this new course so its conditional probability is calculated using *expectation-maximization* (EM).




### BNs in R

*bnlearn* is a popular package for using BNs. We now run through an example to demonstrate its use.

```{r Bnlearn Example Data,message = FALSE, warning = FALSE}
library(bnlearn)
data(learning.test)
kable(head(learning.test))
```

```{r Str of Learning.Test}
str(learning.test)
```

We learn the structure of this Bayesian network using hc. After doing so we can plot the network using visNetwork.

```{r Example of Learning Graph Structure}
bn.hc <- hc(learning.test, score = "aic")

label <- names(bn.hc$nodes)
node_list <- data.frame(id = label, label = label)
edge_list <- as.data.frame(bn.hc$arcs)

visNetwork(node_list, edge_list) %>%
  visEdges(arrows = "middle")
```


## Analysis of UBCO Data Science Major Curriculum

Our data set consists of course information from the data science program at UBCO. We have course codes, names, descriptions, and requisite relationships. 

```{r Read in data}
# Read in data
ubco <- read.csv("..\\data\\UBCO\\UBCO_Course_Calendar.csv")
head(ubco)
```

With this we can construct degree pathways through our curriculum and graph them. Since there are many electives within our program there are many possible curriculum graphs. We will analyze the most and least structurally complex curricula and see what patterns emerge. 


### Maximum Structural Complexity

```{r Generate Max Node Coords - Major}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, #
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, #
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, #
    5, 0,
    5, 1,
    5, 2,
    5, 3,
    5, 4, #
    6, 0,
    6, 1,
    6, 2,
    6, 3
))
```


```{r Visualize Max Graph - Major}
load("..\\data\\rdata\\maxGraph.RData")

visNetwork(
  max_graph$node_list,
  max_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    max_graph$sc_total,
    "Total Blocking Factor:",
    max_graph$bf_total,
    "Total Delay Factor:",
    max_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Examining our maximally complex graph we can learn the set of key courses that are contributing most to our metrics. The total structural complexity is 194, the total blocking factor is 80, and the total delay factor is 114.

The most central node in this graph by far is STAT 230 with a centrality factor of 138. In UBCO's Data Science program is it the first statistics course many students encounter and is a preq-requisite to many 3rd and 4th year classes. Coming in at second is MATH 101 at 95. This also makes sense as it is Calculus 2 as it is a pre-requisite for STAT 230 and the Calculus 3 class MATH 200. Finally COSC 221 is 3rd with 70. This course is discrete math and is a pre-requisite for STAT 230. This suggests as STAT 230 is so central and course that is its pre-requisite is also central.

The course with the greatest blocking factor is MATH 100 with a blocking factor of 17. This course is Calculus 1 and so it is likely unavoidable to for this course to have a high blocking factor. After all, Calulus is the foundation for many courses in a data science program and so it finds itself the root of many chains of edges.

The course with the greatest delay factor is tied for MATH 100, MATH 101, STAT 230, COSC 221, DATA 311, and DATA 410. These courses find themselves a part of the longest path in the graph of length 6. This suggests being able to take DATA 410 is difficult within this curriculum structure as it is very easy to get delayed along the pre-requisite path to this course.

The course with the largest structural complexity is MATH 100 with a score of 23. This is followed by MATH 101 at 20 and COSC 221 at 14. It is interesting that STAT 230 comes at 4th with only a strucutral complexity of 12. Because MATH 100 and 101 find them selves at the root of many paths it follow that they add quite heavily to the structural complexity of our graph.

These metrics suggest a revision of pathways including STAT 230, MATH 100, MATH 101, and COSC 221.

Here is a full table of the metrics
```{r Print Max Graph Metrics - Major}
kable(max_graph$node_list)
```

### Minimum Structural Complexity

```{r Generate Min Node Coords - Major}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, 
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, 
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, 
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, 
    5, 0,
    5, 1,
    5, 2,
    5, 3, 
    6, 0,
    6, 1,
    6, 2,
    6, 3,
    6, 4
))
```

```{r Visualize Min Graph - Major}
load("../data/rdata/minGraph.RData")

visNetwork(
  min_graph$node_list,
  min_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    min_graph$sc_total,
    "Total Blocking Factor:",
    min_graph$bf_total,
    "Total Delay Factor:",
    min_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Examining the minimally complex graph we see quite a large reduction in the total metrics. The total structurcal complexity is 148, the total blocking factor is 55, and the total delay factor is 93.

However the course with the highest centrality factor is once again STAT 230 at 110; the courses with the highest blocking factors are MATH 100 (14), MATH 101 (10), and COSC 221 (6); the courses with the highest delay factors are MATH 100, MATH 101, MATH 200, STAT 230, COSC 221, DATA 311, STAT 303, STAT 401, STAT 403, COSC 421, DATA 407, and DATA 315 all at 5—suggesting multiple longest pathways; and the courses with the greatest structural complexity are MATH 100 (19), MATH 101 (15), and COSC 221 (11).

These results tell us that while upper year electives can vary and reduce the over all metric scores, there are common courses who contribute the most to complexity. Based on this restructuring is need surrounding STAT 230 and COSC 221. Since STAT 230 leads in centrality by more than double across both graphs it is a course that earns increased focus and dedication of resources. Another option for STAT 230 would be the creation of new courses to lessen its affect as a bottleneck. It is unlikely much can be down with MATH 100 and MATH 101 as they are students' first introduction to Calculus and very foundational to all courses in the curriculum though further exploration is certainly warranted.


Here is a full table of the metrics
```{r Print Min Graph Metrics - Major}
kable(min_graph$node_list)
```


The difference in elective coruses that caused the total metric scores to be so different are given below.

The courses in the max graph that are not found in the min graph are:

```{r Print Max Unique Courses - Major}
idx <- !(max_graph$node_list$label %in% min_graph$node_list$label)
kable(data.frame(Courses=max_graph$node_list$label[idx]))
```

The courses in the min graph that are not found in the max graph are:

```{r Print Min Unique Courses - Major}
idx <- !(min_graph$node_list$label %in% max_graph$node_list$label)
kable(data.frame(Courses=min_graph$node_list$label[idx]))
```

## Analysis of UBCO Data Science Minor Curriculum

Data Science minors are far more common at UBCO than the major. Therefore examination of the minor could prove fruitful as there will be a larger data pool for our machine learning models and restructuring of the minor will impact more students. We explore the maximally and minimally complex minor curriculum graphs. Minors are only 30 credits simply sampling 30 credits worth of courses will exclude important prerequisite courses. We still wish to examine how courses flow into one another therefore we sample 30 credits of minor courses and represent these nodes as circles. We then add triangles for prerequisite courses that are not counted towards the minor but would still be required to take if the student wished to complete the minor counting courses.

#### Maximum Structural Complexity

```{r Generate Max Node Coords - Minor}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, #
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, #
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, #
    5, 0,
    5, 1,
    5, 2,
    5, 3,
    5, 4
))
```

```{r Visualize Max Graph - Minor}
load("..\\data\\rdata\\maxGraph_minor.RData")

visNetwork(
  max_graph$node_list,
  max_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    max_graph$sc_total,
    "Total Blocking Factor:",
    max_graph$bf_total,
    "Total Delay Factor:",
    max_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )%>%
  visGroups(groupname = "TRUE", color = "red") %>%
  visGroups(groupname = "FALSE", color = "lightblue") %>%
  visLegend(width = 0.1, position = "right", main = "Is a Preqreq in the Minor")
```

The maximally complex minor graph has a total structural complexity of 188, a total blocking factor of 67, and a total delay factor of 121. The minor represented in this graph is overly complex and likely would never appear in a student's degree. Its structure is an artifact of PSYO 373's and APSC 254;s inclusion in the minor. PSYO 373 is added so Psychology students can have access to the minor however, it forces many PYSO prerequisites to be included in the graph. Similarly for APSC 254, its inclusion is to make the minor available to engineering students though once again it inflates the total metric scores as in order to take it there are many engineering specific courses required. There is very little chance a student would take both PSYO 373 and APSC 254 as minor counting credits. With that being said it could still be interesting to see how the minor counting courses act with respect to their various factors.

The highest centrality node in the graph is STAT 230 with 116 followed by MATH 101 at 74.

The most crucial node is MATH 100 at 17 and the second most crucial node is MATH 101 at 15. These are also the highest blocking factor nodes at 11 and 9 respectively.

The greatest delay factor is 6 with the following courses being a part of the longest pathways: STAT 230, DATRA 311, PSYO 373, DATA 410, MATH 100, MATH 101, COSC 221, PSYO 372. PSYO 270, PSYO 271, PSYO 111, PSYO 121.

A full list of these courses and their metrics is given below.

```{r Print Max Graph Metrics - Minor}
kable(max_graph$node_list)
```

#### Minimum Structural Complexity

```{r Generate Min Node Coords - Minor}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, #
    3, 0,
    3, 1,
    3, 2
))
```

```{r Visualize Min Graph - Minor}

load("..\\data\\rdata\\minGraph_minor.RData")


visNetwork(
  min_graph$node_list,
  min_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    min_graph$sc_total,
    "Total Blocking Factor:",
    min_graph$bf_total,
    "Total Delay Factor:",
    min_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )%>%
  visGroups(groupname = "TRUE", color = "red") %>%
  visGroups(groupname = "FALSE", color = "lightblue") %>%
  visLegend(width = 0.1, position = "right", main = "Is a Preqreq in the Minor")
```

The minimally complex minor graph has a total structural complexity of 80, a total blocking factor of 29, and a total delay factor of 51. This graph would be far more common for STEM students.

The most central node is STAT 230 with a centrality factor of 66 followed by MATH 101 with a factor fo 44.

The most crucial nodes are MATH 100 and MATH 101 with a cruciality of 13 and 12 respectively. They also hold the highest blocking factors of 8 and 7 respectively. 

The greatest delay factor is 5 for the following courses: STAT 230, COSC 221, DATA 405, DATA 315, MATH 100, and MATH 101.

A full list of nodes and their metrics is printed below.

```{r Print Min Graph Metrics - Minor}
kable(min_graph$node_list)
```

The difference in elective courses that caused the total metric scores to be so different are given below.

The courses in the max graph that are not found in the min graph are:

```{r Print Max Unique Courses - Minor}
idx <- !(max_graph$node_list$label %in% min_graph$node_list$label)
kable(data.frame(Courses=max_graph$node_list$label[idx]))
```

The courses in the min graph that are not found in the max graph are:

```{r Print Min Unique Courses - Minor}
idx <- !(min_graph$node_list$label %in% max_graph$node_list$label)
kable(data.frame(Courses=min_graph$node_list$label[idx]))
```

## Creation of Math Stream

Including MATH 409 increases structural complexity drastically as it requires a host of pre-requisite course not already available within the Data Science major. This suggests the possibility of a mathematics stream within Data Science where 2nd and 3rd year math courses would be made mandatory. We investigate the structure of a such a program below. Again due to graph variance we examine the most and least structurally complex graphs.

### Maximum Structural Complexity

```{r Generate Max Node Coords - Math}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, #
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, #
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, #
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, #
    5, 0,
    5, 1,
    5, 2,
    5, 3,
    5, 4, #
    6, 0,
    6, 1,
    6, 2,
    6, 3,
    6, 4
))
```


```{r Visualize Max Graph - Math}
load("..\\data\\rdata\\maxGraph_math.RData")

visNetwork(
  max_graph$node_list,
  max_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    max_graph$sc_total,
    "Total Blocking Factor:",
    max_graph$bf_total,
    "Total Delay Factor:",
    max_graph$df_total
  )
) %>%
  visEdges(arrows = "to") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Beginning with our maximally structurally complex graph we have a total structural complexity of 192, total blocking factor of 77, and a total delay factor of 115.

Our most central course is once again STAT 230 with a centrality factor of 116 however MATH 101 has closed the gap quite well and is at 107. This values are relatively quite close to each other where in previous graphs STAT 230 greatly exceeded any other node's centrality.

The highest cruciality is MATH 100 with 24 and in second is MATH 101 with 20. As this is a math stream the importance of the early foundation calculus courses has increased. They act as a prerequisite to many courses and are the source nodes for many pathways which acts to increase these metrics. Unsurprisingly these courses also hold the highest blocking factors of 18 and 14 for MATH 100 and 101 respectively.

The highest delay factor is 6 for the following courses: MATH 100, MATH 101, STAT 230, COSC 221, DATA 311, DATA 410. This longest path is consistent with what we view previously in the normal DS major analysis.

A full list of nodes and their metrics is printed below.

```{r Print Max Graph Metrics - Math}
kable(max_graph$node_list)
```

### Minimum Structural Complexity

```{r Generate Min Node Coords - Math}
# Specify node locations
coords <- matrix(ncol = 2, byrow = T, data = c(
    1, 0,
    1, 1,
    1, 2,
    1, 3,
    1, 4, 
    2, 0,
    2, 1,
    2, 2,
    2, 3,
    2, 4, 
    3, 0,
    3, 1,
    3, 2,
    3, 3,
    3, 4, 
    4, 0,
    4, 1,
    4, 2,
    4, 3,
    4, 4, 
    5, 0,
    5, 1,
    5, 2,
    5, 3, 
    6, 0,
    6, 1,
    6, 2, 
    6, 3,
    6,4
))
```

```{r Visualize Min Graph - Math}
load("../data/rdata/minGraph_math.RData")

visNetwork(
  min_graph$node_list,
  min_graph$edge_list,
  submain = paste(
    "Total Structural Complexity:",
    min_graph$sc_total,
    "Total Blocking Factor:",
    min_graph$bf_total,
    "Total Delay Factor:",
    min_graph$df_total
  )
) %>%
  visEdges(arrows = "middle") %>%
  visIgraphLayout(layout = "layout.norm", layoutMatrix = coords) %>%
  visEvents(
    selectNode = "function(properties) {
      alert(' sc: ' + this.body.data.nodes.get(properties.nodes[0]).sc + ' cf: ' + this.body.data.nodes.get(properties.nodes[0]).cf + ' bf: ' + this.body.data.nodes.get(properties.nodes[0]).bf + ' df: ' + this.body.data.nodes.get(properties.nodes[0]).df);}"
  )
```

Examining our minimally structurally complex graph we have a total structural complexity of 166, total blocking factor of 63, and a total delay factor of 103.

Interestingly our most central node becomes MATH 10 at 82 followed by STAT 230 at 66. MATH 100 exceeding STAT 230 is likely a result of the reduction is upper year DATA course like 410 in favor of STAT courses like 400 and 403. Removing these DATA courses reduced the amount of paths through STAT 230. AS we added many more math courses the number of long paths through MATH 101 has increased. Thus we find ourselves with a curriculum where MATH 101 is most central.

The highest crucialities once again are MATH 100 with 22 and MATH 101 with 18. These courses are also the highest blocking factors at 17 and 13 respectively. This further confirms that in a MATH stream failing to succeed in these introductory calculus courses will have long lasting effects.
S
The highest delay factor is 5 and there are many courses with this delay factor as it is a common path length. These courses are MATH 100, MATH 101, MATH 200, STAT 230, COSC 221, DATA 311, STAT 303, STAT 403, MATH 409, DATA 407, DATA 315, MATH 319, MATH 225.

A full list of nodes and their metrics is printed below.

```{r Print Min Graph Metrics - Math}
kable(min_graph$node_list)
```

The difference in elective courses that caused the total metric scores to be so different are given below.

The courses in the max graph that are not found in the min graph are:

```{r Print Max Unique Courses - Math}
idx <- !(max_graph$node_list$label %in% min_graph$node_list$label)
kable(data.frame(Courses=max_graph$node_list$label[idx]))
```

The courses in the min graph that are not found in the max graph are:

```{r Print Min Unique Courses - Math}
idx <- !(min_graph$node_list$label %in% max_graph$node_list$label)
kable(data.frame(Courses=min_graph$node_list$label[idx]))
```

## References

::: {#refs}
:::


